<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://muyizixiu.github.io/page/13/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://muyizixiu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Laravel-where-cache" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/01/28/Laravel-where-cache/" class="article-date">
  <time class="dt-published" datetime="2018-01-28T00:00:00.000Z" itemprop="datePublished">2018-01-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>►<a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/php/">php</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/01/28/Laravel-where-cache/">Laravel where 条件缓存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Laravel-where-条件缓存"><a href="#Laravel-where-条件缓存" class="headerlink" title="Laravel where 条件缓存"></a>Laravel where 条件缓存</h1><p>在Laravel中，使用门面提供的DB类，以QueryBuilder的形式去操作数据库是一种很常见的形式。由DB::table($tablename)提供的对象即是QueryBuilder类的。这里面值得注意的一点是：在获取完数据之后，QueryBuilder 对象并不会释放其缓存内容。这里的缓存内容指的是查询条件，例如：where,join,groups等条件。这有可能会导致一个问题，下面是问题代码的示范:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">\DB::listen(function($query)&#123;</span><br><span class="line">    echo &quot;\n&quot;,$query-&gt;sql;</span><br><span class="line">&#125;);</span><br><span class="line">\DB::table(&#x27;seeed_user&#x27;)-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;=&#x27;,&#x27;1&#x27;)-&gt;get();//正常查询</span><br><span class="line">\DB::table(&#x27;seeed_user&#x27;)-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;!=&#x27;,&#x27;1&#x27;)-&gt;get();//正常查询</span><br><span class="line">$table = \DB::table(&#x27;seeed_user&#x27;);//缓存QueryBuilder对象</span><br><span class="line">$table-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;=&#x27;,&#x27;1&#x27;)-&gt;get();//正常查询</span><br><span class="line">$table-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;!=&#x27;,&#x27;1&#x27;)-&gt;get();//这里的sql查询不正常,受上一条查询sql的影响</span><br></pre></td></tr></table></figure>

<p>其打印内容为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from `seeed_user` where `id` = ?</span><br><span class="line">select * from `seeed_user` where `id` != ?</span><br><span class="line">select * from `seeed_user` where `id` = ?</span><br><span class="line">select * from `seeed_user` where `id` = ? and `id` != ?</span><br></pre></td></tr></table></figure>
<p>前两条sql明显是正确的，在缓存QueryBuilder对象之后，最后一条sql明显收到了前一条sql的影响。</p>
<p>这里的测试是基于lumen框架(laravel框架的简化版)和phpunit，完整代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class ExampleTest extends TestCase</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public function testQueryBuilder()</span><br><span class="line">    &#123;</span><br><span class="line">        \DB::listen(function($query)&#123;</span><br><span class="line">            echo &quot;\n&quot;,$query-&gt;sql;</span><br><span class="line">        &#125;);</span><br><span class="line">        \DB::table(&#x27;seeed_user&#x27;)-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;=&#x27;,&#x27;1&#x27;)-&gt;get();</span><br><span class="line">        \DB::table(&#x27;seeed_user&#x27;)-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;!=&#x27;,&#x27;1&#x27;)-&gt;get();</span><br><span class="line">        $table = \DB::table(&#x27;seeed_user&#x27;);</span><br><span class="line">        $table-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;=&#x27;,&#x27;1&#x27;)-&gt;get();</span><br><span class="line">        $table-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;!=&#x27;,&#x27;1&#x27;)-&gt;get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用phpunit –verbose 选项可以观察到sql的打印。</p>
<p>另外两个值得注意的源码知识点是：</p>
<ol>
<li>在laravel中开启了withEloquent（在bootstrap/app.php中），实际上就有了class_alias(类别名)，就如同上面的DB类，可以直接在使用根命名空间\DB;</li>
<li>Laravel的Database的实现如果想迁移到其余框架里面，除了向laravel一样注入配置，还可以利用里面实现的Capsule类</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2018/01/28/Laravel-where-cache/" data-id="ckqhxvqft0000phnchlfj4n14" data-title="Laravel where 条件缓存" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vim-map" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/03/18/vim-map/" class="article-date">
  <time class="dt-published" datetime="2017-03-18T00:00:00.000Z" itemprop="datePublished">2017-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/03/18/vim-map/">vim之键映射</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前面我有两篇文章，关于vim的<a target="_blank" rel="noopener" href="http://blog.muyizixiu.cn/vim/">入门</a>和<a target="_blank" rel="noopener" href="http://blog.muyizixiu.cn/vim-autocmd/">autocmd</a>，随着对vim使用的更加深入，vim的配置便不得不提了！</p>
<h2 id="keycodes"><a href="#keycodes" class="headerlink" title="keycodes"></a>keycodes</h2><p>在vim脚本中，键的映射总是伴随着一些奇怪的符号！例&lt;TAB&gt;,&lt;ESC&gt;这些从字面上可以揣测出来的tab键和esc键，还有些难以猜测的，&lt;S-…&gt;,&lt;A-…&gt;,&lt;CR&gt;。这些事vim的keycode。<br>&lt;S-…&gt;和&lt;A-…&gt;是组合键，前者是指shift键组合其余的按键，后者则是Alt键的组合。例如&lt;S-r&gt;,则是指shit组合字母r键。<br>查看每一个详细的按键，在命令模式下，输入:h keycodes 即可</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>键映射的关键字是各种map。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="center">Normal(常规模式)</th>
<th align="center">Visual(可视化)</th>
<th align="center">Insert(插入模式)</th>
<th align="center">Command(命令行模式)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:map</td>
<td align="center">有效</td>
<td align="center">有效</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">:nmap</td>
<td align="center">仅在该模式有效</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">:vmap</td>
<td align="center"></td>
<td align="center">仅在该模式有效</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">:map!</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">有效</td>
</tr>
<tr>
<td align="left">:imap</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">仅在该模式有效</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">:cmap</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">仅在该模式有效</td>
</tr>
</tbody></table>
<p>可以看出，map加不同的前缀和后缀组成了不同的映射方式。要注意的是，这里的前缀，n,i,v,c都是对应在各自的模式下才生效。以上所有的映射都是嵌套的（nested），当把一个键或者组合键映射到另一个键或者组合键时，被映射的键或者组合键又映射到另外的键时，会向下嵌套。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map a b</span><br><span class="line">map b c</span><br></pre></td></tr></table></figure>
<p>就等同于将a映射至了c,如果不想发生这种副作用时，在map前加入nore。inoremap,noremap,cnoremap等映射则不发生嵌套。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>仅仅是将一个键映射为另外一个键是没有多大意义的，map映射可以将键映射到命令上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &lt;S-r&gt; call reload()</span><br></pre></td></tr></table></figure>
<p>shit组合字母r键，则调用了reload函数，当然，实际上vim没有reload这个函数。<br>这就是vim快捷键的配置。</p>
<h2 id="清除映射"><a href="#清除映射" class="headerlink" title="清除映射"></a>清除映射</h2><p>mapclear可以清除所有map的映射，单个映射的清楚则是在对应的映射命令字的map前面加上字母un。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map a b</span><br><span class="line">umap a</span><br><span class="line">imap &lt;S-c&gt;</span><br><span class="line">iunmap &lt;S-c&gt;</span><br><span class="line">&quot;清除所有map的映射则使用mapclear</span><br><span class="line">mapclear</span><br><span class="line">&quot;清除所有imap的映射则使用imapclear</span><br><span class="line">imapclear</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2017/03/18/vim-map/" data-id="ckqhxvqgo000zphnc61468h29" data-title="vim之键映射" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hexo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/02/28/hexo/" class="article-date">
  <time class="dt-published" datetime="2017-02-28T00:00:00.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/02/28/hexo/">hexo博客指南</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近因为着迷于银河系漫游指南，所以大言不惭地把标题标为指南。其实这里只是我利用hexo搭建博客的小小经验而已,我原来有在daocloud上搭建一个免费的博客，用来尝尝docker的鲜。现在博客资源过期，就鼓捣下把博客迁移到自己的服务器上来了！</p>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>hexo的<a target="_blank" rel="noopener" href="https://hexo.io/">文档</a>看上去很复杂，其实用起来是相当简单的，不像我原来使用的ghost要依赖数据库，整个目录也是干净透明的。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>有nodejs环境的话，一句话搞定。-g选项指明我们安装到全局路径中，默认会在环境变量中的path下安装一个可执行文件。<br>如果需要安装nodejs的话，可以参考各个平台的安装方式，我在centos下执行的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#yum -y install nodejs</span><br></pre></td></tr></table></figure>
<p>也是相当简单的！</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用的文档相对比较复杂,实际的操作其实是相当简单的,了解几个相对简单的概念就能灵活使用hexo了。<br>首先,大胆地建立一个工程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init hello</span><br></pre></td></tr></table></figure>
<p>建立以hello为根目录的工程之后，了解如下几个文件夹和文件的概念就可以顺利使用了！</p>
<ol>
<li><p>文章目录<br>在hello/source/_posts/下，就是你的MarkDown文件了，你在这里写md的文件，hexo会替你生产出文章来的</p>
</li>
<li><p>网页目录<br>hello/publics/就是你的网页了，hexo generate之后，这里便有所有在md文章目录下的所有对应的网页了，不依赖其余目录，这就是一个可以独立导出的网页目录。配合nignx或者其他网络server便可以实现网页浏览博客的效果了！值得一提的是，官方自己也实现了一个webserver 命令：hexo server，可以用来直接访问该网页目录。</p>
</li>
<li><p>配置文件<br>由于你只提供了文章，想要在样式和一些指定内容上做些自己的变更，就需要在配置文件上做相应的变更了。文件的地址是：hello/_config.yml（其实还有themes下面的配置）<br>网站的标题，副标题，描述等等个性化的设置都在这个文件里配置，详细的文档可以参观<a target="_blank" rel="noopener" href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a></p>
</li>
<li><p>主题<br>博客要想华丽起来，离不开<a target="_blank" rel="noopener" href="https://hexo.io/themes/">hexo themes</a>，大量的主题，在GitHub都有源，下载下来，或者git clone下来，到hello/themes/下面，然后在配置文件里面指定主题即可。<br>在下载下来的主题文件夹里面也会有_config.yml的配置文件，实现各个主题个性化！我使用的是一款简单的，文字友好型的<a target="_blank" rel="noopener" href="https://github.com/gaoryrt/hexo-theme-pln">主题</a>!</p>
</li>
<li><p>我的策略<br>hexo generate依赖工程和你的md文件，生成了静态的网页，网页目录是可以脱离于工程存在的，同时，我也将md的文件分离了出来，用git进行管理，这样，我的文章便在github上保留了<a target="_blank" rel="noopener" href="https://github.com/muyizixiu/blog">一份源</a>，可以脱离这个工程进行写作。同时我将工程中的文章目录(hello/source/_posts),指向我的github地址，每次新的文章被提交时，由github的webhook触发远程脚本.脚本将文章pull下来，同时用hexo generate生成静态的网页，再将其复制到webserver所指定的地址。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2017/02/28/hexo/" data-id="ckqhxvqgg000kphnc6q0lgl36" data-title="hexo博客指南" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ios" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/02/28/ios/" class="article-date">
  <time class="dt-published" datetime="2017-02-28T00:00:00.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/02/28/ios/">IOS之旅</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>兜兜转转，发现拓展总是要比深耕来得容易，于是乎，拥抱了ios，再一次地体味了久违的兴奋之感。在我而言，前端的引路人其实是React，这一优秀的web框架改变了我对于前端操作dom的无聊印象，flex亦使得布局不在垒砌像素。</p>
<p>初识ios，便惊讶于objective-C的繁杂，以及浩瀚的API。一开始，犯了心情急迫，高估自己，低看敌方的错误。花了一个小时不多，咕噜吞枣似地把objective-C的语法过了一遍，操之过急地开始学习ios。objective-C的语法跟流行语言相差很大，又有C的黑魔法加持，建议要对C语言有一定了解，才去好好学习objective-C。斯坦福大学出品的IOS开发教程很是经典，借助于它，我对ios的整体才有了一定的认识，十分感激。</p>
<h3 id="UI篇"><a href="#UI篇" class="headerlink" title="UI篇"></a>UI篇</h3><p>UI和布局是入门的好去处，熟悉label，Button，TextField，switch，tableview，scrollview等常用的view的基本属性，其余的留待工作中加深体验。</p>
<h3 id="事件篇"><a href="#事件篇" class="headerlink" title="事件篇"></a>事件篇</h3><p>手势和MVC赋予UI和布局以活力，使你的app开始有了生命力。MVC模式理解简单，认真实践这一模式却要求开发者责任和技巧并存。这个时候练习就显得相当地重要了，跟着Apple<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html">官方的教程</a>走了一遍，也是相当划得来的买卖。</p>
<h3 id="网络和线程"><a href="#网络和线程" class="headerlink" title="网络和线程"></a>网络和线程</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2017/02/28/ios/" data-id="ckqhxvqgh000mphnc1nkig1m9" data-title="IOS之旅" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-sar" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/10/11/linux-sar/" class="article-date">
  <time class="dt-published" datetime="2016-10-11T00:00:00.000Z" itemprop="datePublished">2016-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/10/11/linux-sar/">Linux之sar</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一个好的linuxer想要熟悉自己正在玩弄的系统的状态，可不能只看360的悬浮球。linux下查看系统状态的命令多如牛毛！像top，lsof，fdisk，iostat，du，甚至乎cat一下/proc目录下文件，读读这些晦涩难懂的数据也是可以一窥系统全貌的。然而，居然有杀手般的sar命令在此，我们为何不来一发呢！</p>
<h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><p>超长的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sar  [ -A ] [ -b ] [ -B ] [ -c ] [ -d ] [ -i interval ] [ -p ] [ -q ] [ -r ] [ -R ] [ -t ] [ -u ] [ -v ] [ -V ] [ -w ] [ -W ] [ -y ] [ -n &#123; DEV | EDEV | NFS | NFSD</span><br><span class="line">       | SOCK | ALL &#125; ] [ -x &#123; pid | SELF | ALL &#125; ] [ -X &#123; pid | SELF | ALL &#125; ] [ -I &#123; irq | SUM | ALL | XALL &#125; ] [ -P &#123; cpu | ALL &#125; ] [ -o [ filename ] | -f [ filename ]] [ -s [ hh:mm:ss ] ] [ -e [ hh:mm:ss ] ] [ interval [ count ] ]</span><br></pre></td></tr></table></figure>
<p>用法乍看是有点繁杂的，其实，众多的用法是因为其可选项众多而已，可选项众多意味着其功能广泛。且其用法也是相当简洁的，众多参数对应的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-b:io状态</span><br><span class="line">-B:页交换的状态</span><br><span class="line">-c:任务创建的状态</span><br><span class="line">-d:磁盘状态</span><br><span class="line">-n:网络状态</span><br><span class="line">-u:cpu状态(无任何时，默认是查看cpu状态)</span><br><span class="line">-P:指定cpu的状态</span><br><span class="line">-q:系统负载，任务队列的状态</span><br><span class="line">-r:内存和交互分区状态</span><br><span class="line">-R:内存状态</span><br></pre></td></tr></table></figure>
<p>其中有[ interval [ count ]参数，当指定这俩个参数事，会以interval秒去查看count次当前的状态。不指定该参数则查看从当天开始到现在时间的历史数据。</p>
<h3 id="sar之查看网速"><a href="#sar之查看网速" class="headerlink" title="sar之查看网速"></a>sar之查看网速</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># sar -n DEV</span><br><span class="line">12:00:01 AM     IFACE   rxpck/s   txpck/s   rxbyt/s   txbyt/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">12:10:01 AM        lo     11.10     11.10    738.91    738.91      0.00      0.00      0.00</span><br><span class="line">12:10:01 AM      eth0    167.08    170.74  29037.82  14849.14      0.00      0.00      0.00</span><br><span class="line">12:20:02 AM        lo     11.03     11.03    734.42    734.42      0.00      0.00      0.00</span><br><span class="line">12:20:02 AM      eth0    556.00    559.64  84234.67  46365.23      0.00      0.00      0.00</span><br><span class="line">12:30:02 AM        lo     11.06     11.06    735.89    735.89      0.00      0.00      0.00</span><br><span class="line">12:30:02 AM      eth0   3007.27   3010.13 433371.24 244914.96      0.00      0.00      0.00</span><br><span class="line">12:40:02 AM        lo     11.05     11.05    735.69    735.69      0.00      0.00      0.00</span><br><span class="line">12:40:02 AM      eth0    929.72    933.30 137352.27  76655.95      0.00      0.00      0.00</span><br><span class="line">12:50:01 AM        lo     11.05     11.05    735.55    735.55      0.00      0.00      0.00</span><br><span class="line">12:50:01 AM      eth0   3030.71   3034.50 434493.03 246797.75      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>
<p>选项-n需要指定额外的关键字：{ DEV | EDEV | NFS | NFSD | SOCK | ALL }，DEV指定查看网络设备上的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># sar -n DEV 1 2</span><br><span class="line">11:26:11 AM     IFACE   rxpck/s   txpck/s   rxbyt/s   txbyt/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">11:26:12 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">11:26:12 AM      eth0   1598.00   1602.00 226739.00 129800.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">11:26:12 AM     IFACE   rxpck/s   txpck/s   rxbyt/s   txbyt/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">11:26:13 AM        lo     27.27     27.27   1857.58   1857.58      0.00      0.00      0.00</span><br><span class="line">11:26:13 AM      eth0    100.00    135.35  30420.20  15892.93      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>
<p>以一秒的速度查看俩次网络状态，IFACE是指网络设备，其中rxbyt/s（recieved）以及txbyt/s（transimitted）是指网络流量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2016/10/11/linux-sar/" data-id="ckqhxvqgi000ophnc5p1lhfnv" data-title="Linux之sar" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vim-autocmd" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/10/10/vim-autocmd/" class="article-date">
  <time class="dt-published" datetime="2016-10-10T00:00:00.000Z" itemprop="datePublished">2016-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/10/10/vim-autocmd/">vimrc之autocmd</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>有句话说得好，如果EMACS是神的编辑器，那么vim就是编辑器之神了！vim和emacs极佳的扩展性，以及众多活跃的插件，是经常切换多语言编程的利器。那么，vimrc是vimer进阶不得不掌握的战场了！</p>
<p>vimrc是vim的配置文件， 强大如编程语言一般！</p>
<h2 id="autocmd"><a href="#autocmd" class="headerlink" title="autocmd"></a>autocmd</h2><p>autocmd是用于注册vim事件的处理方法，可以用于在特定事件（读，写，新建文本等）下触发特定的动作。<br>autocmd的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:au[tocmd] [group] &#123;event&#125; &#123;pat&#125; [nested] &#123;cmd&#125;</span><br></pre></td></tr></table></figure>
<p>关键字au[tocmd]是少不了的，{group}是组名称，用于将当前所定义的注册命令归属于一个组，缺省的话默认是当前组，当前组可以用:augroup查看。event是指事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">名字                    激活条件 </span><br><span class="line"></span><br><span class="line">        读入</span><br><span class="line">|BufNewFile|            开始编辑尚不存在的文件</span><br><span class="line">|BufReadPre|            开始编辑新缓冲区，读入文件前</span><br><span class="line">|BufRead|               开始编辑新缓冲区，读入文件后</span><br><span class="line">|BufReadPost|           开始编辑新缓冲区，读入文件后</span><br><span class="line">|BufReadCmd|            开始编辑新缓冲区前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|FileReadPre|           用 &quot;:read&quot; 命令读入文件前</span><br><span class="line">|FileReadPost|          用 &quot;:read&quot; 命令读入文件后</span><br><span class="line">|FileReadCmd|           用 &quot;:read&quot; 命令读入文件前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|FilterReadPre|         用过滤命令读入文件前</span><br><span class="line">|FilterReadPost|        用过滤命令读入文件后</span><br><span class="line"></span><br><span class="line">|StdinReadPre|          从标准输入读入缓冲区前</span><br><span class="line">|StdinReadPost|         从标准输入读入缓冲区后</span><br><span class="line"></span><br><span class="line">        写回</span><br><span class="line">|BufWrite|              开始把整个缓冲区写回到文件</span><br><span class="line">|BufWritePre|           开始把整个缓冲区写回到文件</span><br><span class="line">|BufWritePost|          把整个缓冲区写回到文件后</span><br><span class="line">|BufWriteCmd|           把整个缓冲区写回到文件前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|FileWritePre|          开始把缓冲区部分内容写回到文件</span><br><span class="line">|FileWritePost|         把缓冲区部分内容写回到文件后</span><br><span class="line">|FileWriteCmd|          把缓冲区部分内容写回到文件前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|FileAppendPre|         开始附加到文件</span><br><span class="line">|FileAppendPost|        附加到文件后</span><br><span class="line">|FileAppendCmd|         附加到文件前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|FilterWritePre|        开始为过滤命令或 diff 写到文件</span><br><span class="line">|FilterWritePost|       为过滤命令或 diff 写到文件后</span><br><span class="line"></span><br><span class="line">        缓冲区</span><br><span class="line">|BufAdd|                刚把缓冲区附加到缓冲区列表后</span><br><span class="line">|BufCreate|             刚把缓冲区附加到缓冲区列表后</span><br><span class="line">|BufDelete|             从缓冲区列表删除缓冲区前</span><br><span class="line">|BufWipeout|            从缓冲区列表完全删除缓冲区前</span><br><span class="line"></span><br><span class="line">|BufFilePre|            改变当前缓冲区名字前</span><br><span class="line">|BufFilePost|           改变当前缓冲区名字后</span><br><span class="line"></span><br><span class="line">|BufEnter|              进入缓冲区后</span><br><span class="line">|BufLeave|              转到其它缓冲区前</span><br><span class="line">|BufWinEnter|           在窗口显示缓冲区前</span><br><span class="line">|BufWinLeave|           从窗口删除缓冲区前</span><br><span class="line"></span><br><span class="line">|BufUnload|             卸载缓冲区前</span><br><span class="line">|BufHidden|             刚把缓冲区变为隐藏后</span><br><span class="line">|BufNew|                刚建立新缓冲区后</span><br><span class="line"></span><br><span class="line">|SwapExists|            检测到交换文件已经存在</span><br><span class="line"></span><br><span class="line">        选项</span><br><span class="line">|FileType|              设置 &#x27;filetype&#x27; 选项时</span><br><span class="line">|Syntax|                设置 &#x27;syntax&#x27; 选项时</span><br><span class="line">|EncodingChanged|       &#x27;encoding&#x27; 选项改变后</span><br><span class="line">|TermChanged|           &#x27;term&#x27; 的值改变后</span><br><span class="line"></span><br><span class="line">        启动和退出</span><br><span class="line">|VimEnter|              完成所有的初始化步骤后</span><br><span class="line">|GUIEnter|              成功启动 GUI 后</span><br><span class="line">|GUIFailed|             启动 GUI 失败之后</span><br><span class="line">|TermResponse|          收到 |t_RV| 的终端应答后</span><br><span class="line"></span><br><span class="line">|QuitPre|               用 `:quit` 时，决定是否退出之前</span><br><span class="line">|VimLeavePre|           退出 Vim 前，在写入 viminfo 文件之前</span><br><span class="line">|VimLeave|              退出 Vim 前，在写入 viminfo 文件之后</span><br><span class="line"></span><br><span class="line">        杂项</span><br><span class="line">|FileChangedShell|      Vim 注意到文件在编辑开始后被改变</span><br><span class="line">|FileChangedShellPost|  对在编辑开始后被改变的文件的处理完成后</span><br><span class="line">|FileChangedRO|         对只读文件进行第一次修改前</span><br><span class="line"></span><br><span class="line">|ShellCmdPost|          执行外壳命令后</span><br><span class="line">|ShellFilterPost|       用外壳命令执行完过滤后</span><br><span class="line"></span><br><span class="line">|FuncUndefined|         调用没有定义的用户函数</span><br><span class="line">|SpellFileMissing|      使用不存在的拼写文件</span><br><span class="line">|SourcePre|             执行 Vim 脚本之前</span><br><span class="line">|SourceCmd|             执行 Vim 脚本之前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|VimResized|            Vim 窗口大小改变后</span><br><span class="line">|FocusGained|           Vim 得到输入焦点</span><br><span class="line">|FocusLost|             Vim 失去输入焦点</span><br><span class="line">|CursorHold|            用户有一段时间没有按键</span><br><span class="line">|CursorHoldI|           在插入模式下，用户有一段时间没有按键</span><br><span class="line">|CursorMoved|           普通模式下移动了光标</span><br><span class="line">|CursorMovedI|          插入模式下移动了光标</span><br><span class="line"></span><br><span class="line">|WinEnter|              进入其它窗口后</span><br><span class="line">|WinLeave|              离开窗口前</span><br><span class="line">|TabEnter|              进入其它标签页后</span><br><span class="line">|TabLeave|              离开标签页前</span><br><span class="line">|CmdwinEnter|           进入命令行窗口后</span><br><span class="line">|CmdwinLeave|           离开命令行窗口前</span><br><span class="line"></span><br><span class="line">|InsertEnter|           开始插入模式前</span><br><span class="line">|InsertChange|          在插入或替换模式下输入 &lt;Insert&gt; 时</span><br><span class="line">|InsertLeave|           离开插入模式时</span><br><span class="line">|InsertCharPre|         插入模式输入每个字符前</span><br><span class="line"></span><br><span class="line">|ColorScheme|           载入色彩方案后</span><br><span class="line"></span><br><span class="line">|RemoteReply|           得到了 Vim 服务器的应答</span><br><span class="line"></span><br><span class="line">|QuickFixCmdPre|        执行 quickfix 命令前</span><br><span class="line">|QuickFixCmdPost|       执行 quickfix 命令后</span><br><span class="line"></span><br><span class="line">|SessionLoadPost|       载入会话文件后</span><br><span class="line"></span><br><span class="line">|MenuPopup|             刚要显示弹出菜单前</span><br><span class="line">|CompleteDone|          插入模式补全结束之后</span><br><span class="line"></span><br><span class="line">|User|                  和 &quot;:doautocmd&quot; 一起使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引用自<a target="_blank" rel="noopener" href="http://vimcdoc.sourceforge.net/doc/autocmd.html#autocmd-events">VIMCDOC</a>。</p>
<p>模式匹配则是对当前文本类型的一种匹配，支持通配符，eg: *.php匹配php文本。<br>{nested}则是指明可以嵌套事件，当所处理的动作也被注册为事件触发另一动作时，默认不触发。</p>
<p>{cmd}就是我们在vim命令模式下面经常使用的了，复杂的动作可以使用函数来处理。</p>
<p>##Example<br>在我的vimrc脚本中，利用了autocmd在保存的时候对php文件进行语法检查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">au BufWrite *.php call phpSyntaxCheck()</span><br></pre></td></tr></table></figure>
<p>这里的phpSyntaxCheck是自定义的vim函数，call phpSyntaxCheck()调用这个函数，函数里面调用外部的php -l 检查文件，匹配到错误则输出</p>
<p>另外一个给我带来很大便利的是，新建文件的时候，加入一些定制的头部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">au BufNewFile *.php call InsertPHPHeader()</span><br><span class="line"></span><br><span class="line">func InsertPHPHeader()</span><br><span class="line">	call append(0,&quot;&lt;?php&quot;)</span><br><span class="line">endf</span><br></pre></td></tr></table></figure>

<p>这是一个简单的例子，定义了一个函数，插入php文件的头部一些字符串。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2016/10/10/vim-autocmd/" data-id="ckqhxvqgn000xphncf4dg96up" data-title="vimrc之autocmd" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-php-string-error" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/08/26/php-string-error/" class="article-date">
  <time class="dt-published" datetime="2016-08-26T00:00:00.000Z" itemprop="datePublished">2016-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/08/26/php-string-error/">PHP 字符异常</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>php作为一门弱类型语言！字符串的处理显得要比强类型语言要灵活且复杂很多！隐藏的类型转换，较多的字符串处理函数，中文字符的处理，转义等等无疑是有很多坑的！</p>
<p>字符串乱码的问题其实比较好解决，无非就是做到正确的编码，但是utf-8编码却有个小插曲！为了让程序更好地区分unicode编码采用的实现方式，头部带了几个不可见字符（也就是BOM），目前普遍采用utf-8的编码格式的情形下，带BOM的php脚本在被require活着include之后就会出现问题，在 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br></pre></td></tr></table></figure>
<p>之前的文本会被当做文本流输出到标准输出中！然而0xEF,0xBB,0xBF这三个字符是不可见的，导致正常的输出变成了类似于乱码的格式！由于windows普遍鸟BOM，而unix普通不鸟BOM，同一份代码可能表现上不同，有BOM的在输出上会出现字符异常！实际上编码也是正常的，把不可见字符删除就行了！</p>
<p>同理而言，在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br></pre></td></tr></table></figure>
<p> 之前的不可见字符都有可能导致字符异常，因为php大多数情形下是以输出作为返回值的，所以不可见字符可能导致很多类似于，头几个字母乱码，非正常json等现象！</p>
<p>另外值得一提的是，json_encode 会对中文字符进行unicode转义，以及在类型比较的时候会发生隐藏的类型转换！这两者在开发过程中都是比较常见的，在暗流涌动的php代码上，我们要在自以为上面多一层验证，php的测试是很必要的；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2016/08/26/php-string-error/" data-id="ckqhxvqgk000sphnc1e5v8e3e" data-title="PHP 字符异常" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-encoding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/06/20/encoding/" class="article-date">
  <time class="dt-published" datetime="2016-06-20T00:00:00.000Z" itemprop="datePublished">2016-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/06/20/encoding/">unicode utf-8 and encoding</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>编码总是个问题，尤其是在数据历经不同平台，甚至是不同程序下！今天来捋清楚看似简单的编码问题。</p>
<p><strong>所有的编码都是指，字符以何种二进制形式存储起来！</strong></p>
<h5 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h5><p>ASCII码是十分基础的编码，囊括了英文字母，数字和不可打印的控制字符，一共是128个。ASCII码用一个字节的存储，占用了二进制：0000 0000 – 0111 1111<br>这样的一个经典编码，对于英语国家来说或许够用了。但是我大中华上下五千年，汉字上万个，显然是一个字节的二进制是无法表达清楚的，又考虑到不同国家编码标准不一致，导致同一个二进制存储的数据对应的字符不一致。万国码，unicode码也就蛋生了！</p>
<h5 id="unicode码"><a href="#unicode码" class="headerlink" title="unicode码"></a>unicode码</h5><p>unicode码为每个字符设定了统一并且唯一的一个整数（正式说法是code），也就是说，使用了unicode码为编码规范的字符对应的二进制存储是唯一的。比如说字符“2”：对应的数字是0x32。在shell下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root#  echo -e &quot;\u32&quot;</span><br><span class="line">root#  2</span><br></pre></td></tr></table></figure>
<p>‘\u’是转义符，是指该字符的unicode码。</p>
<p>那么问题来了，这种unicode码的字符，对应的二进制存储是什么样的！</p>
<p>实际上，unicode码仅规定了字符对应的那个整数是什么！并没有规定如何存储，所以unicode码的实现方式又有很多种，这里介绍下大名鼎鼎的utf-8编码！</p>
<h5 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h5><p>1）对于只有一个单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码（那就是那个整数）。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2）对于n字节的符号，第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
<p>utf-8实现了unicode编码规范，互联网中绝大多数平台都采用了她，而非其余的unicode编码规范。</p>
<h5 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h5><p>在网络中，经常见到中文被转义了，变成了对应的unicode转义码，如上面的’\u32’。值得注意的是，这里不是乱码，而是被转义了。常见的一些原因是中文在某些协议中不被支持，从而转义成常见字符。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2016/06/20/encoding/" data-id="ckqhxvqg40005phncajzz6e3a" data-title="unicode utf-8 and encoding" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-trace" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/04/26/trace/" class="article-date">
  <time class="dt-published" datetime="2016-04-26T00:00:00.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/04/26/trace/">strace 和基友 ltrace</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>正如其字面意思一样，trace即追踪。在操作系统里面，进程是一个相对独立的单位，在不知其源代码的情形下，要想知道一个进程在做些什么，这就是strace和ltrace所干的活了。</p>
<p>因为其重要性和其能发挥的力量，我在这里就直接翻译linux中的man文档，以促使其完整和准确。</p>
<h2 id="strace：-追踪系统调用和信号量"><a href="#strace：-追踪系统调用和信号量" class="headerlink" title="strace： 追踪系统调用和信号量"></a>strace： 追踪系统调用和信号量</h2><p>1.解释<br>在一般的情形下，strace运行指定的命令，直至其结束。一个进程所接收的信号和进行的系统调用将会被strace拦截并记录。每个系统调用的名字，其参数，连同其返回值都将在标准错误中打印出来，如果使用了-o参数的时候，就会写入到指定的文件。</p>
<p>strace是一个可以用于诊断，学习的调试工具。借由其不需重新编译去追踪程序的特征，系统管理员，调试工程师，debugger在不知道源代码的情形下，也可以发挥它在解决问题上的无限能力。学生们，黑客以及那些过于好奇的家伙们，可以通过追踪那些普通程序来学习很多操作系统的知识。程序员们，同样也将会发现，因为系统调用和信号量都是发生在内核和用户态的交汇处，借此可以有效地隔离bug，做完整性的检查，以及发现死锁的发生。</p>
<p>追踪打印的每一行都包含了系统调用的名字，以及被括号包围的参数和其返回值。使用cat /dev/null 作为一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;/dev/null&quot;,O_RDONLY) = 3</span><br></pre></td></tr></table></figure>
<p>错误的发生（一般返回值为-1）会有错误符号和错误信息追加在后面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;/foo/bar&quot;, O_RDONLY) = -1 ENOENT (No such file or directory)</span><br></pre></td></tr></table></figure>
<p>信号打印出来的是其信号符号和信号文字。sleep 666的一个启动和终止的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigsuspend([] &lt;unfinished ...&gt;</span><br><span class="line">--- SIGINT (Interrupt) ---</span><br><span class="line">+++ killed by SIGINT +++</span><br></pre></td></tr></table></figure>

<p>如果一个系统调用发生时，另外的线程或者进程调用了一个系统调用，此时，strace会保存这些事件的顺序并且标记该调用为unfinished，当调用有返回时，再标记为resumed。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[pid 28772] select(4, [3], NULL, NULL, NULL &lt;unfinished ...&gt;</span><br><span class="line">[pid 28779] clock_gettime(CLOCK_REALTIME, &#123;1130322148, 939977000&#125;) = 0</span><br><span class="line">[pid 28772] &lt;... select resumed&gt; )      = 1 (in [3])</span><br></pre></td></tr></table></figure>
<p>接收到的信号中断一个（可重启的）系统调用与内核中断系统调用并在信号处理完毕之后立即重新执行是不同的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read(0, 0x7ffff72cf5cf, 1)              = ? ERESTARTSYS (To be restarted)</span><br><span class="line">--- SIGALRM (Alarm clock) @ 0 (0) ---</span><br><span class="line">rt_sigreturn(0xe)                       = 0</span><br><span class="line">read(0, &quot;&quot;..., 1)                       = 0</span><br></pre></td></tr></table></figure>

<p>参数以人性化的方式打印出来，一个shell执行&gt;&gt;xyzzy 输出重定向的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(&quot;xyzzy&quot;, O_WRONLY|O_APPEND|O_CREAT, 0666) = 3</span><br></pre></td></tr></table></figure>
<p>在这里，open函数的3个参数之后的标志参数变成了按位或的形式且打印出了惯用的八进制的形式。在原始形式和惯用形式不同于ANSI或者POSIX标准时，更加偏好使用标准形式。在一些案例中，strace表现出了比源代码更易读的特性。</p>
<p>结构体指针会被解释，其成员会被以合适的方式打印出来。全部都是以类似于c语言的形式。例如，ls -l /dev/null 的实际执行被追踪如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lstat(&quot;/dev/null&quot;, &#123;st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...&#125;) = 0</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2016/04/26/trace/" data-id="ckqhxvqgl000uphncfzwg2z4v" data-title="strace 和基友 ltrace" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-golang-channel" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/01/20/golang-channel/" class="article-date">
  <time class="dt-published" datetime="2016-01-20T00:00:00.000Z" itemprop="datePublished">2016-01-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/01/20/golang-channel/">channel!channel!</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>进程之间的通信是很复杂的，线程之间共享全局数据则妙的多。而goroutine之间的通信依靠的channel就是妙不可言了。</p>
<h4 id="channel的一些特性"><a href="#channel的一些特性" class="headerlink" title="channel的一些特性"></a>channel的一些特性</h4><h6 id="1-有缓存和无缓存的channel"><a href="#1-有缓存和无缓存的channel" class="headerlink" title="1. 有缓存和无缓存的channel"></a>1. 有缓存和无缓存的channel</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c:=make(chan int,10)  //这是有缓存的</span><br><span class="line">c0:=make(chan int)    //这是无缓存的</span><br></pre></td></tr></table></figure>
<p>这样一点在初学时，是关注的比较多的，无缓存的channel要求goroutine之间的读写是同时的。</p>
<h6 id="2-带读写方向的channel"><a href="#2-带读写方向的channel" class="headerlink" title="2. 带读写方向的channel"></a>2. 带读写方向的channel</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var c &lt;-chan int   //此处的channel是只能读的</span><br><span class="line">var c0 chan&lt;- int  //此处的channel是只写的</span><br></pre></td></tr></table></figure>
<p>其实这里是很有意思的，也推荐多使用带读写方向的channel，goroutine之间的分工就更加明显了。</p>
<h5 id="3-channel的关闭"><a href="#3-channel的关闭" class="headerlink" title="3.channel的关闭"></a>3.channel的关闭</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c:=make(chan int,10)    //实例化一个有缓存的channel</span><br><span class="line">close(c)                //关闭channel</span><br><span class="line">a,ok:=&lt;-c               //在关闭之后，读取channel，这里是有问题的，已关闭的channel读不到数据，这里用了一个多返回值来判断是否关闭了channel</span><br><span class="line">b:=&lt;-c                  //直接读数据是会引发panic的</span><br></pre></td></tr></table></figure>
<p>这里有一点注意，就是channel的关闭问题，是否需要关闭呢！因为channel是goroutine之间的通信，各个goroutine共享了这个内存，不关闭是不是会引起内存泄露的问题呢！作为全局变量声明的，是不会被gc回收的。而像普通变量时，在所有引用channel的goroutine不在引用时，便会进行gc回收，所以不关闭，内存最终还是会被回收的。另外要注意的一点就是，只读channel不能关闭，仔细思考起来，这样一点也体现了golang对channel的设计用心。</p>
<h5 id="4-遍历channel"><a href="#4-遍历channel" class="headerlink" title="4. 遍历channel"></a>4. 遍历channel</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for v:=range c&#123;</span><br><span class="line">     println(v)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>channel更像是一个管道，所以这里的遍历显得有点不可思议。其实这里如同循环的读取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for&#123;</span><br><span class="line">    if v,ok:=c;ok&#123;</span><br><span class="line">        println(v)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样代码就臃肿了些。</p>
<h5 id="5-消息队列案例"><a href="#5-消息队列案例" class="headerlink" title="5.消息队列案例"></a>5.消息队列案例</h5><p>在消息队列中，基本的也比较简单的模型有生产者和消费者模型，golang能以很美妙的姿态实现它</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">func main()&#123;</span><br><span class="line">    c:=make(chan int,10)</span><br><span class="line">    go Consume(c)</span><br><span class="line">    go Consume(c)</span><br><span class="line">    go Create(c)    </span><br><span class="line">    select&#123;&#125;        //永久休眠，保证其余goroutine的时间片</span><br><span class="line">&#125;</span><br><span class="line">func Consume(c &lt;-chan int)&#123;</span><br><span class="line">    for v:=range c&#123;</span><br><span class="line">        println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func Create(c chan&lt;- int)&#123;</span><br><span class="line">    for i:=0;i&lt;1000;i++&#123;</span><br><span class="line">        c&lt;-i</span><br><span class="line">    &#125;</span><br><span class="line">    close(c)       //在写入处关闭channel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分代码就像实现了三个线程（实际上是三个协程），线程之间的数据以队列（channel）的方式来处理。</p>
<p>另外值得一提的是，golang在channel设计中，在只读的channel处提供多返回值来检测channel是否关闭，而只写入的channel则没有办法判断channel是否关闭，如果写入已经关闭的channel会引发panic。与之相反的是，在只读channel处是不允许关闭的，会产生语法错误。可写入的channel自然是可以关闭的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2016/01/20/golang-channel/" data-id="ckqhxvqg70007phncf1dggkv5" data-title="channel!channel!" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/14/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/php/">php</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/29/panya/start_c_1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/29/panya/start_g_0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/29/panya/%E4%BA%A7%E5%93%81%E4%B8%8E%E6%9C%8D%E5%8A%A1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/29/panya/%E5%80%8B%E4%BA%BA%E4%B8%AD%E5%BF%83/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/06/29/panya/%E5%84%AA%E6%83%A0%E6%B4%BB%E5%8B%95/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>