<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://muyizixiu.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://muyizixiu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-curl" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/02/26/curl/" class="article-date">
  <time class="dt-published" datetime="2018-02-26T00:00:00.000Z" itemprop="datePublished">2018-02-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/02/26/curl/">curl追踪http请求跳转</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在网路中，http(s)跳转是常见的一种行为，例如：301永久重定向，302临时重定向。而curl是一种命令行发起请求的工具。在工作中，我们项目遇到一个难以理解的跳转行为，最终利用curl和nginx配置文件，理解了该跳转行为。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>项目中存在一个老的资源地址 <a target="_blank" rel="noopener" href="http://www.old.com/">www.old.com</a>, 仅支持http访问。新的需求要求将一个新的地址 <a target="_blank" rel="noopener" href="http://www.new.com/">www.new.com</a>, 无论http/https都要跳转至 <a target="_blank" rel="noopener" href="http://www.old.com/">www.old.com</a>. 需求相对较为简单，团队内部开发人员t讨论的实现方式为：</p>
<ol>
<li>将 <a target="_blank" rel="noopener" href="https://www.new.com/">https://www.new.com</a> 在 nginx 中 rewrite 至 <a target="_blank" rel="noopener" href="http://www.new.com/">http://www.new.com</a>.</li>
<li>在 <a target="_blank" rel="noopener" href="http://www.new.com/">http://www.new.com</a> 的虚拟 server 中使用 nginx 的 proxy_pass 代理至 <a target="_blank" rel="noopener" href="http://www.old.com/">http://www.old.com</a>.</li>
</ol>
<p>理论上这样便可以实现当前的要求. 测试时发现，<a target="_blank" rel="noopener" href="https://www.new.com/">https://www.new.com</a> 跳转至 <a target="_blank" rel="noopener" href="http://www.old.com/">http://www.old.com</a> 正常，但 <a target="_blank" rel="noopener" href="http://www.new.com/">http://www.new.com</a> 跳入了一个错误的地址, <a target="_blank" rel="noopener" href="https://www.wrong.com/">https://www.wrong.com</a>.<br>实际导致该问题出现有两部分原因：</p>
<ol>
<li>开发人员实际设置 <a target="_blank" rel="noopener" href="https://www.new.com/">https://www.new.com</a> 跳转至 <a target="_blank" rel="noopener" href="http://new.com/">http://new.com</a>. 而 new.com 的 nginx 配置与 <a target="_blank" rel="noopener" href="http://www.new.com/">www.new.com</a> 一致，共享同一个 server 块。</li>
<li>目的地地址 <a target="_blank" rel="noopener" href="http://www.old.com/">www.old.com</a> 识别跳转地址，如果是特定的地址（本项目中为 <a target="_blank" rel="noopener" href="http://www.new.com/">www.new.com</a> ）则跳转入 <a target="_blank" rel="noopener" href="http://www.wrong.com/">www.wrong.com</a>.</li>
</ol>
<p>问题不是很复杂，但是每个原因都很偶然，且难以直接分辨, 表现形式也诡异。<a target="_blank" rel="noopener" href="https://www.new.com/">https://www.new.com</a> 跳转正常，<a target="_blank" rel="noopener" href="http://www.new.com/">http://www.new.com</a> 则失败。</p>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>处理该 bug 时，首要想法是弄清楚每一个跳转行为。三个方案可以实现该目标：</p>
<ol>
<li>浏览器开发者工具中查看网络请求</li>
<li>nginx 可以设置 rewrite_log. 可以在 error_log 的 info 信息中查看跳转行为</li>
<li>curl 请求模拟<br>因为跳转时301永久重定向，浏览器刷新查看网络请求就显得比较麻烦；而 nginx rewrite_log 则需要在线上服务器中修改配置，请求量过多会导致日志追查困难。curl 是个命令行工具，也无需考虑缓存问题。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -I http://www.new.com</span><br><span class="line"># -I 选项只查看 http head 信息</span><br></pre></td></tr></table></figure>
<p>仅查看 http head 信息发现，跳转至了一个移动端的地址 m.new.com, 而非原先的错误地址。随后查看 nginx 配置得知，移动端的跳转利用了 user agent, 根据 user agent 判断是否来自移动端，如果是，则进行移动端跳转。curl 请求默认的 user agent 则为 curl, 在移动端跳转规则之内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -A PC -I http://www.new.com</span><br><span class="line"># -A 选项指定user agent</span><br></pre></td></tr></table></figure>
<p>替换 user agent 发现, <a target="_blank" rel="noopener" href="http://www.new.com/">http://www.new.com</a> 跳转至错误地址 <a target="_blank" rel="noopener" href="https://www.wrong.com/">https://www.wrong.com</a>. 问题复现！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -A PC -I -L http://www.new.com</span><br><span class="line"># -L 选项使 curl 跟随每次跳转请求，这样我们可以观察到所有 rewrite 行为了。</span><br></pre></td></tr></table></figure>
<p>排除 user agent 问题后，发现跳转行为一如 nginx 配置，<a target="_blank" rel="noopener" href="http://www.new.com/">http://www.new.com</a> 直接跳转至 <a target="_blank" rel="noopener" href="http://wrong.com/">http://wrong.com</a>, 再接着升级为 <a target="_blank" rel="noopener" href="https://wrong.com/">https://wrong.com</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -A PC -I -L https://www.new.com</span><br><span class="line"># https 的请求追随</span><br></pre></td></tr></table></figure>
<p>而 https 的请求跳转行为为：<a target="_blank" rel="noopener" href="https://www.new.com/">https://www.new.com</a>, <a target="_blank" rel="noopener" href="https://new.com/">https://new.com</a>, <a target="_blank" rel="noopener" href="http://www.old.com/">http://www.old.com</a>. 跳转成功。对比两个跳转行为，问题1则被发现了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -v -A PC -I -L http://www.new.com</span><br><span class="line"># -v 选项指定查看请求详细信息</span><br></pre></td></tr></table></figure>
<p>在接下来的详细信息中，我们能观察到每次跳转请求的服务器地址。因为 <a target="_blank" rel="noopener" href="http://www.new.com/">http://www.new.com</a> 并非跳转至 <a target="_blank" rel="noopener" href="http://www.old.com/">http://www.old.com</a>, 而是代理（即 proxy_pass ）。无法观察出任何跳转信息，而在服务器响应的 response 中，我们观察到，http header 中有字段 X-Powerd-By: PHP/5.60. 判断出该跳转乃是目标地址的 php 脚本行为。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2018/02/26/curl/" data-id="ckqhy2ca70004m0nehzplb20o" data-title="curl追踪http请求跳转" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mysql-bin-log" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/01/29/mysql-bin-log/" class="article-date">
  <time class="dt-published" datetime="2018-01-29T00:00:00.000Z" itemprop="datePublished">2018-01-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>►<a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/mysql/">mysql</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/01/29/mysql-bin-log/">bin-log备份脚本</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="binlog备份脚本"><a href="#binlog备份脚本" class="headerlink" title="binlog备份脚本"></a>binlog备份脚本</h1><p>出于想日常备份binlog的缘故，编写了一个可以定期连接远程mysql server并下载binlog日志的脚本。</p>
<h2 id="mysql-bin-log"><a href="#mysql-bin-log" class="headerlink" title="mysql bin log"></a>mysql bin log</h2><p>mysql 有多种日志类型，在一个长期running的项目中，值得研究的两个日志是：慢日志（slow log）,二进制日志 (bin log)。前者相对较为简单，连接到mysql server或者在配置中配置好时间，并且开启，可以观察到运行较慢的sql，后者往往用于数据同步。binlog是一种mysql数据库记录数据变更操作的二进制日志，mysql server会记录一定量的日志，并利用二进制日志来实现数据主从数据同步。远程连接mysql server可以下载一定时间内的binlog日志，更长时间范围的需要直接取对应的存储位置下载。二进制日志记录了每一个使数据变跟的sql，通过这一功能，我们可以恢复确定时间点的数据，本质上就是日志追踪了每一个使数据变更的操作，然后再重复所有变更操作。</p>
<h2 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#备份binlog日志</span><br><span class="line">#利用sql &#x27;show master logs&#x27; 查看binlog日志</span><br><span class="line">#命令行输入密码时，如果存在特殊字符，除了转义外，还可以使用单引号，单引号里的内容不会被shell解释为特殊含义</span><br><span class="line">mysql_binlog_filename=$(mysql -u username -p&#x27;password&#x27; -h host -e &quot;show master logs&quot;|grep &quot;mysql-bin&quot;|awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">for file in $mysql_binlog_filename</span><br><span class="line">do</span><br><span class="line">	dirname=$(date &quot;+%y-%m-%d&quot;)</span><br><span class="line">	if ! test -d $dirname</span><br><span class="line">	then</span><br><span class="line">		mkdir $dirname</span><br><span class="line">	fi</span><br><span class="line">	#远程读取binlog日志</span><br><span class="line">	`mysqlbinlog -u username -p&#x27;password&#x27; -h host --read-from-remote-server $file --result-file=$dirname/$file  -v --base64-output=decode-rows`</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><ol>
<li>mysqlbinlog 连接到远程服务器，可以下载指定的binlog日志</li>
<li>-v 参数可以导出更多详细信息</li>
<li>–base64-output指定解析binlog，decode-rows可以解析为带注释的sql，另外的可选值包括已经放弃的always，以及不解析的never。</li>
<li>下载日志时,使用低版本的mysqlbinlog和高版本的mysql server会导致校验失败: Slave can not handle replication events with the checksum that master is configured to log;</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2018/01/29/mysql-bin-log/" data-id="ckqhy2cao000qm0ne4i1d4heu" data-title="bin-log备份脚本" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Laravel-where-cache" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/01/28/Laravel-where-cache/" class="article-date">
  <time class="dt-published" datetime="2018-01-28T00:00:00.000Z" itemprop="datePublished">2018-01-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>►<a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/php/">php</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/01/28/Laravel-where-cache/">Laravel where 条件缓存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Laravel-where-条件缓存"><a href="#Laravel-where-条件缓存" class="headerlink" title="Laravel where 条件缓存"></a>Laravel where 条件缓存</h1><p>在Laravel中，使用门面提供的DB类，以QueryBuilder的形式去操作数据库是一种很常见的形式。由DB::table($tablename)提供的对象即是QueryBuilder类的。这里面值得注意的一点是：在获取完数据之后，QueryBuilder 对象并不会释放其缓存内容。这里的缓存内容指的是查询条件，例如：where,join,groups等条件。这有可能会导致一个问题，下面是问题代码的示范:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">\DB::listen(function($query)&#123;</span><br><span class="line">    echo &quot;\n&quot;,$query-&gt;sql;</span><br><span class="line">&#125;);</span><br><span class="line">\DB::table(&#x27;seeed_user&#x27;)-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;=&#x27;,&#x27;1&#x27;)-&gt;get();//正常查询</span><br><span class="line">\DB::table(&#x27;seeed_user&#x27;)-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;!=&#x27;,&#x27;1&#x27;)-&gt;get();//正常查询</span><br><span class="line">$table = \DB::table(&#x27;seeed_user&#x27;);//缓存QueryBuilder对象</span><br><span class="line">$table-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;=&#x27;,&#x27;1&#x27;)-&gt;get();//正常查询</span><br><span class="line">$table-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;!=&#x27;,&#x27;1&#x27;)-&gt;get();//这里的sql查询不正常,受上一条查询sql的影响</span><br></pre></td></tr></table></figure>

<p>其打印内容为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from `seeed_user` where `id` = ?</span><br><span class="line">select * from `seeed_user` where `id` != ?</span><br><span class="line">select * from `seeed_user` where `id` = ?</span><br><span class="line">select * from `seeed_user` where `id` = ? and `id` != ?</span><br></pre></td></tr></table></figure>
<p>前两条sql明显是正确的，在缓存QueryBuilder对象之后，最后一条sql明显收到了前一条sql的影响。</p>
<p>这里的测试是基于lumen框架(laravel框架的简化版)和phpunit，完整代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class ExampleTest extends TestCase</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public function testQueryBuilder()</span><br><span class="line">    &#123;</span><br><span class="line">        \DB::listen(function($query)&#123;</span><br><span class="line">            echo &quot;\n&quot;,$query-&gt;sql;</span><br><span class="line">        &#125;);</span><br><span class="line">        \DB::table(&#x27;seeed_user&#x27;)-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;=&#x27;,&#x27;1&#x27;)-&gt;get();</span><br><span class="line">        \DB::table(&#x27;seeed_user&#x27;)-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;!=&#x27;,&#x27;1&#x27;)-&gt;get();</span><br><span class="line">        $table = \DB::table(&#x27;seeed_user&#x27;);</span><br><span class="line">        $table-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;=&#x27;,&#x27;1&#x27;)-&gt;get();</span><br><span class="line">        $table-&gt;select(&#x27;*&#x27;)-&gt;where(&#x27;id&#x27;,&#x27;!=&#x27;,&#x27;1&#x27;)-&gt;get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用phpunit –verbose 选项可以观察到sql的打印。</p>
<p>另外两个值得注意的源码知识点是：</p>
<ol>
<li>在laravel中开启了withEloquent（在bootstrap/app.php中），实际上就有了class_alias(类别名)，就如同上面的DB类，可以直接在使用根命名空间\DB;</li>
<li>Laravel的Database的实现如果想迁移到其余框架里面，除了向laravel一样注入配置，还可以利用里面实现的Capsule类</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2018/01/28/Laravel-where-cache/" data-id="ckqhy2c9y0000m0ne1dtkaeqo" data-title="Laravel where 条件缓存" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vim-map" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/03/18/vim-map/" class="article-date">
  <time class="dt-published" datetime="2017-03-18T00:00:00.000Z" itemprop="datePublished">2017-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/03/18/vim-map/">vim之键映射</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前面我有两篇文章，关于vim的<a target="_blank" rel="noopener" href="http://blog.muyizixiu.cn/vim/">入门</a>和<a target="_blank" rel="noopener" href="http://blog.muyizixiu.cn/vim-autocmd/">autocmd</a>，随着对vim使用的更加深入，vim的配置便不得不提了！</p>
<h2 id="keycodes"><a href="#keycodes" class="headerlink" title="keycodes"></a>keycodes</h2><p>在vim脚本中，键的映射总是伴随着一些奇怪的符号！例&lt;TAB&gt;,&lt;ESC&gt;这些从字面上可以揣测出来的tab键和esc键，还有些难以猜测的，&lt;S-…&gt;,&lt;A-…&gt;,&lt;CR&gt;。这些事vim的keycode。<br>&lt;S-…&gt;和&lt;A-…&gt;是组合键，前者是指shift键组合其余的按键，后者则是Alt键的组合。例如&lt;S-r&gt;,则是指shit组合字母r键。<br>查看每一个详细的按键，在命令模式下，输入:h keycodes 即可</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>键映射的关键字是各种map。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="center">Normal(常规模式)</th>
<th align="center">Visual(可视化)</th>
<th align="center">Insert(插入模式)</th>
<th align="center">Command(命令行模式)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:map</td>
<td align="center">有效</td>
<td align="center">有效</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">:nmap</td>
<td align="center">仅在该模式有效</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">:vmap</td>
<td align="center"></td>
<td align="center">仅在该模式有效</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">:map!</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">有效</td>
</tr>
<tr>
<td align="left">:imap</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">仅在该模式有效</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">:cmap</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">仅在该模式有效</td>
</tr>
</tbody></table>
<p>可以看出，map加不同的前缀和后缀组成了不同的映射方式。要注意的是，这里的前缀，n,i,v,c都是对应在各自的模式下才生效。以上所有的映射都是嵌套的（nested），当把一个键或者组合键映射到另一个键或者组合键时，被映射的键或者组合键又映射到另外的键时，会向下嵌套。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map a b</span><br><span class="line">map b c</span><br></pre></td></tr></table></figure>
<p>就等同于将a映射至了c,如果不想发生这种副作用时，在map前加入nore。inoremap,noremap,cnoremap等映射则不发生嵌套。</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>仅仅是将一个键映射为另外一个键是没有多大意义的，map映射可以将键映射到命令上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map &lt;S-r&gt; call reload()</span><br></pre></td></tr></table></figure>
<p>shit组合字母r键，则调用了reload函数，当然，实际上vim没有reload这个函数。<br>这就是vim快捷键的配置。</p>
<h2 id="清除映射"><a href="#清除映射" class="headerlink" title="清除映射"></a>清除映射</h2><p>mapclear可以清除所有map的映射，单个映射的清楚则是在对应的映射命令字的map前面加上字母un。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map a b</span><br><span class="line">umap a</span><br><span class="line">imap &lt;S-c&gt;</span><br><span class="line">iunmap &lt;S-c&gt;</span><br><span class="line">&quot;清除所有map的映射则使用mapclear</span><br><span class="line">mapclear</span><br><span class="line">&quot;清除所有imap的映射则使用imapclear</span><br><span class="line">imapclear</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2017/03/18/vim-map/" data-id="ckqhy2cat000zm0nefyg4ccrk" data-title="vim之键映射" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hexo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/02/28/hexo/" class="article-date">
  <time class="dt-published" datetime="2017-02-28T00:00:00.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/02/28/hexo/">hexo博客指南</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近因为着迷于银河系漫游指南，所以大言不惭地把标题标为指南。其实这里只是我利用hexo搭建博客的小小经验而已,我原来有在daocloud上搭建一个免费的博客，用来尝尝docker的鲜。现在博客资源过期，就鼓捣下把博客迁移到自己的服务器上来了！</p>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>hexo的<a target="_blank" rel="noopener" href="https://hexo.io/">文档</a>看上去很复杂，其实用起来是相当简单的，不像我原来使用的ghost要依赖数据库，整个目录也是干净透明的。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>有nodejs环境的话，一句话搞定。-g选项指明我们安装到全局路径中，默认会在环境变量中的path下安装一个可执行文件。<br>如果需要安装nodejs的话，可以参考各个平台的安装方式，我在centos下执行的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#yum -y install nodejs</span><br></pre></td></tr></table></figure>
<p>也是相当简单的！</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用的文档相对比较复杂,实际的操作其实是相当简单的,了解几个相对简单的概念就能灵活使用hexo了。<br>首先,大胆地建立一个工程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init hello</span><br></pre></td></tr></table></figure>
<p>建立以hello为根目录的工程之后，了解如下几个文件夹和文件的概念就可以顺利使用了！</p>
<ol>
<li><p>文章目录<br>在hello/source/_posts/下，就是你的MarkDown文件了，你在这里写md的文件，hexo会替你生产出文章来的</p>
</li>
<li><p>网页目录<br>hello/publics/就是你的网页了，hexo generate之后，这里便有所有在md文章目录下的所有对应的网页了，不依赖其余目录，这就是一个可以独立导出的网页目录。配合nignx或者其他网络server便可以实现网页浏览博客的效果了！值得一提的是，官方自己也实现了一个webserver 命令：hexo server，可以用来直接访问该网页目录。</p>
</li>
<li><p>配置文件<br>由于你只提供了文章，想要在样式和一些指定内容上做些自己的变更，就需要在配置文件上做相应的变更了。文件的地址是：hello/_config.yml（其实还有themes下面的配置）<br>网站的标题，副标题，描述等等个性化的设置都在这个文件里配置，详细的文档可以参观<a target="_blank" rel="noopener" href="https://hexo.io/docs/configuration.html">https://hexo.io/docs/configuration.html</a></p>
</li>
<li><p>主题<br>博客要想华丽起来，离不开<a target="_blank" rel="noopener" href="https://hexo.io/themes/">hexo themes</a>，大量的主题，在GitHub都有源，下载下来，或者git clone下来，到hello/themes/下面，然后在配置文件里面指定主题即可。<br>在下载下来的主题文件夹里面也会有_config.yml的配置文件，实现各个主题个性化！我使用的是一款简单的，文字友好型的<a target="_blank" rel="noopener" href="https://github.com/gaoryrt/hexo-theme-pln">主题</a>!</p>
</li>
<li><p>我的策略<br>hexo generate依赖工程和你的md文件，生成了静态的网页，网页目录是可以脱离于工程存在的，同时，我也将md的文件分离了出来，用git进行管理，这样，我的文章便在github上保留了<a target="_blank" rel="noopener" href="https://github.com/muyizixiu/blog">一份源</a>，可以脱离这个工程进行写作。同时我将工程中的文章目录(hello/source/_posts),指向我的github地址，每次新的文章被提交时，由github的webhook触发远程脚本.脚本将文章pull下来，同时用hexo generate生成静态的网页，再将其复制到webserver所指定的地址。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2017/02/28/hexo/" data-id="ckqhy2cak000km0ne0j37cotx" data-title="hexo博客指南" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ios" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/02/28/ios/" class="article-date">
  <time class="dt-published" datetime="2017-02-28T00:00:00.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2017/02/28/ios/">IOS之旅</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>兜兜转转，发现拓展总是要比深耕来得容易，于是乎，拥抱了ios，再一次地体味了久违的兴奋之感。在我而言，前端的引路人其实是React，这一优秀的web框架改变了我对于前端操作dom的无聊印象，flex亦使得布局不在垒砌像素。</p>
<p>初识ios，便惊讶于objective-C的繁杂，以及浩瀚的API。一开始，犯了心情急迫，高估自己，低看敌方的错误。花了一个小时不多，咕噜吞枣似地把objective-C的语法过了一遍，操之过急地开始学习ios。objective-C的语法跟流行语言相差很大，又有C的黑魔法加持，建议要对C语言有一定了解，才去好好学习objective-C。斯坦福大学出品的IOS开发教程很是经典，借助于它，我对ios的整体才有了一定的认识，十分感激。</p>
<h3 id="UI篇"><a href="#UI篇" class="headerlink" title="UI篇"></a>UI篇</h3><p>UI和布局是入门的好去处，熟悉label，Button，TextField，switch，tableview，scrollview等常用的view的基本属性，其余的留待工作中加深体验。</p>
<h3 id="事件篇"><a href="#事件篇" class="headerlink" title="事件篇"></a>事件篇</h3><p>手势和MVC赋予UI和布局以活力，使你的app开始有了生命力。MVC模式理解简单，认真实践这一模式却要求开发者责任和技巧并存。这个时候练习就显得相当地重要了，跟着Apple<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/index.html">官方的教程</a>走了一遍，也是相当划得来的买卖。</p>
<h3 id="网络和线程"><a href="#网络和线程" class="headerlink" title="网络和线程"></a>网络和线程</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2017/02/28/ios/" data-id="ckqhy2cam000mm0ne9awa0orn" data-title="IOS之旅" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux-sar" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/10/11/linux-sar/" class="article-date">
  <time class="dt-published" datetime="2016-10-11T00:00:00.000Z" itemprop="datePublished">2016-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/10/11/linux-sar/">Linux之sar</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一个好的linuxer想要熟悉自己正在玩弄的系统的状态，可不能只看360的悬浮球。linux下查看系统状态的命令多如牛毛！像top，lsof，fdisk，iostat，du，甚至乎cat一下/proc目录下文件，读读这些晦涩难懂的数据也是可以一窥系统全貌的。然而，居然有杀手般的sar命令在此，我们为何不来一发呢！</p>
<h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><p>超长的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sar  [ -A ] [ -b ] [ -B ] [ -c ] [ -d ] [ -i interval ] [ -p ] [ -q ] [ -r ] [ -R ] [ -t ] [ -u ] [ -v ] [ -V ] [ -w ] [ -W ] [ -y ] [ -n &#123; DEV | EDEV | NFS | NFSD</span><br><span class="line">       | SOCK | ALL &#125; ] [ -x &#123; pid | SELF | ALL &#125; ] [ -X &#123; pid | SELF | ALL &#125; ] [ -I &#123; irq | SUM | ALL | XALL &#125; ] [ -P &#123; cpu | ALL &#125; ] [ -o [ filename ] | -f [ filename ]] [ -s [ hh:mm:ss ] ] [ -e [ hh:mm:ss ] ] [ interval [ count ] ]</span><br></pre></td></tr></table></figure>
<p>用法乍看是有点繁杂的，其实，众多的用法是因为其可选项众多而已，可选项众多意味着其功能广泛。且其用法也是相当简洁的，众多参数对应的是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-b:io状态</span><br><span class="line">-B:页交换的状态</span><br><span class="line">-c:任务创建的状态</span><br><span class="line">-d:磁盘状态</span><br><span class="line">-n:网络状态</span><br><span class="line">-u:cpu状态(无任何时，默认是查看cpu状态)</span><br><span class="line">-P:指定cpu的状态</span><br><span class="line">-q:系统负载，任务队列的状态</span><br><span class="line">-r:内存和交互分区状态</span><br><span class="line">-R:内存状态</span><br></pre></td></tr></table></figure>
<p>其中有[ interval [ count ]参数，当指定这俩个参数事，会以interval秒去查看count次当前的状态。不指定该参数则查看从当天开始到现在时间的历史数据。</p>
<h3 id="sar之查看网速"><a href="#sar之查看网速" class="headerlink" title="sar之查看网速"></a>sar之查看网速</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># sar -n DEV</span><br><span class="line">12:00:01 AM     IFACE   rxpck/s   txpck/s   rxbyt/s   txbyt/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">12:10:01 AM        lo     11.10     11.10    738.91    738.91      0.00      0.00      0.00</span><br><span class="line">12:10:01 AM      eth0    167.08    170.74  29037.82  14849.14      0.00      0.00      0.00</span><br><span class="line">12:20:02 AM        lo     11.03     11.03    734.42    734.42      0.00      0.00      0.00</span><br><span class="line">12:20:02 AM      eth0    556.00    559.64  84234.67  46365.23      0.00      0.00      0.00</span><br><span class="line">12:30:02 AM        lo     11.06     11.06    735.89    735.89      0.00      0.00      0.00</span><br><span class="line">12:30:02 AM      eth0   3007.27   3010.13 433371.24 244914.96      0.00      0.00      0.00</span><br><span class="line">12:40:02 AM        lo     11.05     11.05    735.69    735.69      0.00      0.00      0.00</span><br><span class="line">12:40:02 AM      eth0    929.72    933.30 137352.27  76655.95      0.00      0.00      0.00</span><br><span class="line">12:50:01 AM        lo     11.05     11.05    735.55    735.55      0.00      0.00      0.00</span><br><span class="line">12:50:01 AM      eth0   3030.71   3034.50 434493.03 246797.75      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>
<p>选项-n需要指定额外的关键字：{ DEV | EDEV | NFS | NFSD | SOCK | ALL }，DEV指定查看网络设备上的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># sar -n DEV 1 2</span><br><span class="line">11:26:11 AM     IFACE   rxpck/s   txpck/s   rxbyt/s   txbyt/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">11:26:12 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">11:26:12 AM      eth0   1598.00   1602.00 226739.00 129800.00      0.00      0.00      0.00</span><br><span class="line"></span><br><span class="line">11:26:12 AM     IFACE   rxpck/s   txpck/s   rxbyt/s   txbyt/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">11:26:13 AM        lo     27.27     27.27   1857.58   1857.58      0.00      0.00      0.00</span><br><span class="line">11:26:13 AM      eth0    100.00    135.35  30420.20  15892.93      0.00      0.00      0.00</span><br></pre></td></tr></table></figure>
<p>以一秒的速度查看俩次网络状态，IFACE是指网络设备，其中rxbyt/s（recieved）以及txbyt/s（transimitted）是指网络流量。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2016/10/11/linux-sar/" data-id="ckqhy2can000om0ne5fkzb23r" data-title="Linux之sar" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-vim-autocmd" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/10/10/vim-autocmd/" class="article-date">
  <time class="dt-published" datetime="2016-10-10T00:00:00.000Z" itemprop="datePublished">2016-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/10/10/vim-autocmd/">vimrc之autocmd</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>有句话说得好，如果EMACS是神的编辑器，那么vim就是编辑器之神了！vim和emacs极佳的扩展性，以及众多活跃的插件，是经常切换多语言编程的利器。那么，vimrc是vimer进阶不得不掌握的战场了！</p>
<p>vimrc是vim的配置文件， 强大如编程语言一般！</p>
<h2 id="autocmd"><a href="#autocmd" class="headerlink" title="autocmd"></a>autocmd</h2><p>autocmd是用于注册vim事件的处理方法，可以用于在特定事件（读，写，新建文本等）下触发特定的动作。<br>autocmd的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:au[tocmd] [group] &#123;event&#125; &#123;pat&#125; [nested] &#123;cmd&#125;</span><br></pre></td></tr></table></figure>
<p>关键字au[tocmd]是少不了的，{group}是组名称，用于将当前所定义的注册命令归属于一个组，缺省的话默认是当前组，当前组可以用:augroup查看。event是指事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">名字                    激活条件 </span><br><span class="line"></span><br><span class="line">        读入</span><br><span class="line">|BufNewFile|            开始编辑尚不存在的文件</span><br><span class="line">|BufReadPre|            开始编辑新缓冲区，读入文件前</span><br><span class="line">|BufRead|               开始编辑新缓冲区，读入文件后</span><br><span class="line">|BufReadPost|           开始编辑新缓冲区，读入文件后</span><br><span class="line">|BufReadCmd|            开始编辑新缓冲区前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|FileReadPre|           用 &quot;:read&quot; 命令读入文件前</span><br><span class="line">|FileReadPost|          用 &quot;:read&quot; 命令读入文件后</span><br><span class="line">|FileReadCmd|           用 &quot;:read&quot; 命令读入文件前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|FilterReadPre|         用过滤命令读入文件前</span><br><span class="line">|FilterReadPost|        用过滤命令读入文件后</span><br><span class="line"></span><br><span class="line">|StdinReadPre|          从标准输入读入缓冲区前</span><br><span class="line">|StdinReadPost|         从标准输入读入缓冲区后</span><br><span class="line"></span><br><span class="line">        写回</span><br><span class="line">|BufWrite|              开始把整个缓冲区写回到文件</span><br><span class="line">|BufWritePre|           开始把整个缓冲区写回到文件</span><br><span class="line">|BufWritePost|          把整个缓冲区写回到文件后</span><br><span class="line">|BufWriteCmd|           把整个缓冲区写回到文件前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|FileWritePre|          开始把缓冲区部分内容写回到文件</span><br><span class="line">|FileWritePost|         把缓冲区部分内容写回到文件后</span><br><span class="line">|FileWriteCmd|          把缓冲区部分内容写回到文件前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|FileAppendPre|         开始附加到文件</span><br><span class="line">|FileAppendPost|        附加到文件后</span><br><span class="line">|FileAppendCmd|         附加到文件前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|FilterWritePre|        开始为过滤命令或 diff 写到文件</span><br><span class="line">|FilterWritePost|       为过滤命令或 diff 写到文件后</span><br><span class="line"></span><br><span class="line">        缓冲区</span><br><span class="line">|BufAdd|                刚把缓冲区附加到缓冲区列表后</span><br><span class="line">|BufCreate|             刚把缓冲区附加到缓冲区列表后</span><br><span class="line">|BufDelete|             从缓冲区列表删除缓冲区前</span><br><span class="line">|BufWipeout|            从缓冲区列表完全删除缓冲区前</span><br><span class="line"></span><br><span class="line">|BufFilePre|            改变当前缓冲区名字前</span><br><span class="line">|BufFilePost|           改变当前缓冲区名字后</span><br><span class="line"></span><br><span class="line">|BufEnter|              进入缓冲区后</span><br><span class="line">|BufLeave|              转到其它缓冲区前</span><br><span class="line">|BufWinEnter|           在窗口显示缓冲区前</span><br><span class="line">|BufWinLeave|           从窗口删除缓冲区前</span><br><span class="line"></span><br><span class="line">|BufUnload|             卸载缓冲区前</span><br><span class="line">|BufHidden|             刚把缓冲区变为隐藏后</span><br><span class="line">|BufNew|                刚建立新缓冲区后</span><br><span class="line"></span><br><span class="line">|SwapExists|            检测到交换文件已经存在</span><br><span class="line"></span><br><span class="line">        选项</span><br><span class="line">|FileType|              设置 &#x27;filetype&#x27; 选项时</span><br><span class="line">|Syntax|                设置 &#x27;syntax&#x27; 选项时</span><br><span class="line">|EncodingChanged|       &#x27;encoding&#x27; 选项改变后</span><br><span class="line">|TermChanged|           &#x27;term&#x27; 的值改变后</span><br><span class="line"></span><br><span class="line">        启动和退出</span><br><span class="line">|VimEnter|              完成所有的初始化步骤后</span><br><span class="line">|GUIEnter|              成功启动 GUI 后</span><br><span class="line">|GUIFailed|             启动 GUI 失败之后</span><br><span class="line">|TermResponse|          收到 |t_RV| 的终端应答后</span><br><span class="line"></span><br><span class="line">|QuitPre|               用 `:quit` 时，决定是否退出之前</span><br><span class="line">|VimLeavePre|           退出 Vim 前，在写入 viminfo 文件之前</span><br><span class="line">|VimLeave|              退出 Vim 前，在写入 viminfo 文件之后</span><br><span class="line"></span><br><span class="line">        杂项</span><br><span class="line">|FileChangedShell|      Vim 注意到文件在编辑开始后被改变</span><br><span class="line">|FileChangedShellPost|  对在编辑开始后被改变的文件的处理完成后</span><br><span class="line">|FileChangedRO|         对只读文件进行第一次修改前</span><br><span class="line"></span><br><span class="line">|ShellCmdPost|          执行外壳命令后</span><br><span class="line">|ShellFilterPost|       用外壳命令执行完过滤后</span><br><span class="line"></span><br><span class="line">|FuncUndefined|         调用没有定义的用户函数</span><br><span class="line">|SpellFileMissing|      使用不存在的拼写文件</span><br><span class="line">|SourcePre|             执行 Vim 脚本之前</span><br><span class="line">|SourceCmd|             执行 Vim 脚本之前 |Cmd-event|</span><br><span class="line"></span><br><span class="line">|VimResized|            Vim 窗口大小改变后</span><br><span class="line">|FocusGained|           Vim 得到输入焦点</span><br><span class="line">|FocusLost|             Vim 失去输入焦点</span><br><span class="line">|CursorHold|            用户有一段时间没有按键</span><br><span class="line">|CursorHoldI|           在插入模式下，用户有一段时间没有按键</span><br><span class="line">|CursorMoved|           普通模式下移动了光标</span><br><span class="line">|CursorMovedI|          插入模式下移动了光标</span><br><span class="line"></span><br><span class="line">|WinEnter|              进入其它窗口后</span><br><span class="line">|WinLeave|              离开窗口前</span><br><span class="line">|TabEnter|              进入其它标签页后</span><br><span class="line">|TabLeave|              离开标签页前</span><br><span class="line">|CmdwinEnter|           进入命令行窗口后</span><br><span class="line">|CmdwinLeave|           离开命令行窗口前</span><br><span class="line"></span><br><span class="line">|InsertEnter|           开始插入模式前</span><br><span class="line">|InsertChange|          在插入或替换模式下输入 &lt;Insert&gt; 时</span><br><span class="line">|InsertLeave|           离开插入模式时</span><br><span class="line">|InsertCharPre|         插入模式输入每个字符前</span><br><span class="line"></span><br><span class="line">|ColorScheme|           载入色彩方案后</span><br><span class="line"></span><br><span class="line">|RemoteReply|           得到了 Vim 服务器的应答</span><br><span class="line"></span><br><span class="line">|QuickFixCmdPre|        执行 quickfix 命令前</span><br><span class="line">|QuickFixCmdPost|       执行 quickfix 命令后</span><br><span class="line"></span><br><span class="line">|SessionLoadPost|       载入会话文件后</span><br><span class="line"></span><br><span class="line">|MenuPopup|             刚要显示弹出菜单前</span><br><span class="line">|CompleteDone|          插入模式补全结束之后</span><br><span class="line"></span><br><span class="line">|User|                  和 &quot;:doautocmd&quot; 一起使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引用自<a target="_blank" rel="noopener" href="http://vimcdoc.sourceforge.net/doc/autocmd.html#autocmd-events">VIMCDOC</a>。</p>
<p>模式匹配则是对当前文本类型的一种匹配，支持通配符，eg: *.php匹配php文本。<br>{nested}则是指明可以嵌套事件，当所处理的动作也被注册为事件触发另一动作时，默认不触发。</p>
<p>{cmd}就是我们在vim命令模式下面经常使用的了，复杂的动作可以使用函数来处理。</p>
<p>##Example<br>在我的vimrc脚本中，利用了autocmd在保存的时候对php文件进行语法检查。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">au BufWrite *.php call phpSyntaxCheck()</span><br></pre></td></tr></table></figure>
<p>这里的phpSyntaxCheck是自定义的vim函数，call phpSyntaxCheck()调用这个函数，函数里面调用外部的php -l 检查文件，匹配到错误则输出</p>
<p>另外一个给我带来很大便利的是，新建文件的时候，加入一些定制的头部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">au BufNewFile *.php call InsertPHPHeader()</span><br><span class="line"></span><br><span class="line">func InsertPHPHeader()</span><br><span class="line">	call append(0,&quot;&lt;?php&quot;)</span><br><span class="line">endf</span><br></pre></td></tr></table></figure>

<p>这是一个简单的例子，定义了一个函数，插入php文件的头部一些字符串。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2016/10/10/vim-autocmd/" data-id="ckqhy2cas000xm0neciwt9xkv" data-title="vimrc之autocmd" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-php-string-error" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/08/26/php-string-error/" class="article-date">
  <time class="dt-published" datetime="2016-08-26T00:00:00.000Z" itemprop="datePublished">2016-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/08/26/php-string-error/">PHP 字符异常</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>php作为一门弱类型语言！字符串的处理显得要比强类型语言要灵活且复杂很多！隐藏的类型转换，较多的字符串处理函数，中文字符的处理，转义等等无疑是有很多坑的！</p>
<p>字符串乱码的问题其实比较好解决，无非就是做到正确的编码，但是utf-8编码却有个小插曲！为了让程序更好地区分unicode编码采用的实现方式，头部带了几个不可见字符（也就是BOM），目前普遍采用utf-8的编码格式的情形下，带BOM的php脚本在被require活着include之后就会出现问题，在 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br></pre></td></tr></table></figure>
<p>之前的文本会被当做文本流输出到标准输出中！然而0xEF,0xBB,0xBF这三个字符是不可见的，导致正常的输出变成了类似于乱码的格式！由于windows普遍鸟BOM，而unix普通不鸟BOM，同一份代码可能表现上不同，有BOM的在输出上会出现字符异常！实际上编码也是正常的，把不可见字符删除就行了！</p>
<p>同理而言，在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br></pre></td></tr></table></figure>
<p> 之前的不可见字符都有可能导致字符异常，因为php大多数情形下是以输出作为返回值的，所以不可见字符可能导致很多类似于，头几个字母乱码，非正常json等现象！</p>
<p>另外值得一提的是，json_encode 会对中文字符进行unicode转义，以及在类型比较的时候会发生隐藏的类型转换！这两者在开发过程中都是比较常见的，在暗流涌动的php代码上，我们要在自以为上面多一层验证，php的测试是很必要的；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2016/08/26/php-string-error/" data-id="ckqhy2cap000sm0ne0acz2m3r" data-title="PHP 字符异常" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-encoding" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2016/06/20/encoding/" class="article-date">
  <time class="dt-published" datetime="2016-06-20T00:00:00.000Z" itemprop="datePublished">2016-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2016/06/20/encoding/">unicode utf-8 and encoding</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>编码总是个问题，尤其是在数据历经不同平台，甚至是不同程序下！今天来捋清楚看似简单的编码问题。</p>
<p><strong>所有的编码都是指，字符以何种二进制形式存储起来！</strong></p>
<h5 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h5><p>ASCII码是十分基础的编码，囊括了英文字母，数字和不可打印的控制字符，一共是128个。ASCII码用一个字节的存储，占用了二进制：0000 0000 – 0111 1111<br>这样的一个经典编码，对于英语国家来说或许够用了。但是我大中华上下五千年，汉字上万个，显然是一个字节的二进制是无法表达清楚的，又考虑到不同国家编码标准不一致，导致同一个二进制存储的数据对应的字符不一致。万国码，unicode码也就蛋生了！</p>
<h5 id="unicode码"><a href="#unicode码" class="headerlink" title="unicode码"></a>unicode码</h5><p>unicode码为每个字符设定了统一并且唯一的一个整数（正式说法是code），也就是说，使用了unicode码为编码规范的字符对应的二进制存储是唯一的。比如说字符“2”：对应的数字是0x32。在shell下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root#  echo -e &quot;\u32&quot;</span><br><span class="line">root#  2</span><br></pre></td></tr></table></figure>
<p>‘\u’是转义符，是指该字符的unicode码。</p>
<p>那么问题来了，这种unicode码的字符，对应的二进制存储是什么样的！</p>
<p>实际上，unicode码仅规定了字符对应的那个整数是什么！并没有规定如何存储，所以unicode码的实现方式又有很多种，这里介绍下大名鼎鼎的utf-8编码！</p>
<h5 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h5><p>1）对于只有一个单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码（那就是那个整数）。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2）对于n字节的符号，第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
<p>utf-8实现了unicode编码规范，互联网中绝大多数平台都采用了她，而非其余的unicode编码规范。</p>
<h5 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h5><p>在网络中，经常见到中文被转义了，变成了对应的unicode转义码，如上面的’\u32’。值得注意的是，这里不是乱码，而是被转义了。常见的一些原因是中文在某些协议中不被支持，从而转义成常见字符。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://muyizixiu.github.io/2016/06/20/encoding/" data-id="ckqhy2ca80005m0nedi05c5oe" data-title="unicode utf-8 and encoding" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/php/">php</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/02/26/curl/">curl追踪http请求跳转</a>
          </li>
        
          <li>
            <a href="/2018/01/29/mysql-bin-log/">bin-log备份脚本</a>
          </li>
        
          <li>
            <a href="/2018/01/28/Laravel-where-cache/">Laravel where 条件缓存</a>
          </li>
        
          <li>
            <a href="/2017/03/18/vim-map/">vim之键映射</a>
          </li>
        
          <li>
            <a href="/2017/02/28/hexo/">hexo博客指南</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>